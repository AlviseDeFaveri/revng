/// \file main.cpp
/// \brief Standalone program to extract various information from the LLVM IR
///        generated by revamb

// Standard includes
#include <cstdlib>
#include <iostream>
#include <memory>
#include <string>

// LLVM includes
#include "llvm/ADT/StringRef.h"
#include "llvm/IR/AssemblyAnnotationWriter.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/Module.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/Support/SourceMgr.h"

// Local libraries includes
#include "revng/DebugHelper/DebugHelper.h"
#include "revng/StackAnalysis/StackAnalysis.h"
#include "revng/Support/Callgrind.h"
#include "revng/Support/CommandLine.h"
#include "revng/Support/Debug.h"
#include "revng/Support/Statistics.h"

// Local includes
#include "CollectCFG.h"
#include "CollectFunctionBoundaries.h"
#include "CollectNoreturn.h"
#include "IsolateFunctions.h"

using namespace llvm;
using namespace llvm::cl;

using std::string;

namespace {

opt<string> CFGPath("cfg",
                    desc("path where the CFG should be stored"),
                    cat(MainCategory),
                    value_desc("path"));
alias A1("c", desc("Alias for -cfg"), aliasopt(CFGPath), cat(MainCategory));

opt<string> NoreturnPath("noreturn",
                         desc("path where the list of noreturn "
                              "basic blocks should be stored"),
                         cat(MainCategory),
                         value_desc("path"));
alias A2("n",
         desc("Alias for -noreturn"),
         aliasopt(NoreturnPath),
         cat(MainCategory));

#define DESCRIPTION \
  desc("path where the result of the stack analysis should be stored")
opt<string> StackAnalysisPath("stack-analysis",
                              DESCRIPTION,
                              cat(MainCategory),
                              value_desc("path"));
#undef DESCRIPTION

alias A3("s",
         desc("Alias for -stack-analysis"),
         aliasopt(StackAnalysisPath),
         cat(MainCategory));

#define DESCRIPTION                                                            \
  desc("path where a new LLVM module containing the reorganization of the "    \
       "basic blocks into the corresponding functions identified by function " \
       "boundaries analysis performed by revamb should be stored")
opt<string> FunctionIsolationPath("function-isolation",
                                  DESCRIPTION,
                                  cat(MainCategory),
                                  value_desc("path"));
#undef DESCRIPTION

alias A4("i",
         desc("Alias for -function-isolation"),
         aliasopt(FunctionIsolationPath),
         cat(MainCategory));

#define DESCRIPTION                                                            \
  desc("path where a new LLVM module containing the reorganization of the "    \
       "basic blocks into the corresponding functions identified by function " \
       "boundaries analysis performed by revamb should be stored")
opt<string> FunctionBoundariesPath("functions-boundaries",
                                   DESCRIPTION,
                                   cat(MainCategory),
                                   value_desc("path"));
#undef DESCRIPTION

alias A5("b",
         desc("Alias for -functions-boundaries"),
         aliasopt(FunctionBoundariesPath),
         cat(MainCategory));

opt<string> InputPath(Positional, Required, desc("<input path>"));

} // namespace

class DumpPass : public FunctionPass {
public:
  static char ID;

public:
  DumpPass() : FunctionPass(ID) {}

  bool runOnFunction(Function &F) override;

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.setPreservesAll();

    if (CFGPath.size() != 0)
      AU.addRequired<CollectCFG>();

    if (NoreturnPath.size() != 0)
      AU.addRequired<CollectNoreturn>();

    if (FunctionBoundariesPath.size() != 0)
      AU.addRequired<CollectFunctionBoundaries>();

    if (StackAnalysisPath.size() != 0)
      AU.addRequired<StackAnalysis::StackAnalysis<true>>();

    if (FunctionIsolationPath.size() != 0)
      AU.addRequired<IsolateFunctions>();
  }

private:
  std::ostream &pathToStream(const std::string &Path, std::ofstream &File) {
    if (Path[0] == '-' && Path[1] == '\0') {
      return std::cout;
    } else {
      if (File.is_open())
        File.close();
      File.open(Path);
      return File;
    }
  }

  void dumpModule(Module *Module, std::string Path) {
    std::ofstream Output;

    // If output path is `-` print on stdout
    // TODO: this solution is not portable, make DebugHelper accept streams
    if (Path[0] == '-' && Path[1] == '\0') {
      Path = "/dev/stdout";
    }

    // Initialize the debug helper object
    DebugHelper Debug(Path, Module, DebugInfoType::LLVMIR, Path);
    Debug.generateDebugInfo();
  }
};

char DumpPass::ID = 0;

bool DumpPass::runOnFunction(Function &) {
  std::ofstream Output;

  if (CFGPath.size() != 0) {
    auto &Analysis = getAnalysis<CollectCFG>();
    Analysis.serialize(pathToStream(CFGPath, Output));
  }

  if (NoreturnPath.size() != 0) {
    auto &Analysis = getAnalysis<CollectNoreturn>();
    Analysis.serialize(pathToStream(NoreturnPath, Output));
  }

  if (FunctionBoundariesPath.size() != 0) {
    auto &Analysis = getAnalysis<CollectFunctionBoundaries>();
    Analysis.serialize(pathToStream(FunctionBoundariesPath, Output));
  }

  if (StackAnalysisPath.size() != 0) {
    auto &Analysis = getAnalysis<StackAnalysis::StackAnalysis<true>>();
    Analysis.serialize(pathToStream(StackAnalysisPath, Output));
  }

  if (FunctionIsolationPath.size() != 0) {
    auto &Analysis = getAnalysis<IsolateFunctions>();
    Module *ModifiedModule = Analysis.getModule();
    dumpModule(ModifiedModule, FunctionIsolationPath);
  }

  return false;
}

int main(int argc, const char *argv[]) {
  Loggers->registerArguments();
  HideUnrelatedOptions({ &MainCategory });
  ParseCommandLineOptions(argc, argv);
  Loggers->activateArguments();
  installStatistics();

  LLVMContext &Context = getGlobalContext();
  SMDiagnostic Err;
  std::unique_ptr<Module> TheModule;
  {
    Callgrind DisableCallgrind(false);
    TheModule = parseIRFile(InputPath, Err, Context);
  }

  if (!TheModule) {
    fprintf(stderr, "Couldn't load the LLVM IR.");
    return EXIT_FAILURE;
  }

  legacy::FunctionPassManager FPM(TheModule.get());
  FPM.add(new DumpPass());
  FPM.run(*TheModule->getFunction("root"));

  return EXIT_SUCCESS;
}
